import subprocess
import sys
import time
import socket
import os
import json

PROJECT_ROOT = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
SETTINGS_PATH = os.path.join(PROJECT_ROOT, "fina_settings.json")

# Configuración de los objetivos (TVs)
# Cada objetivo tiene su IP y su MAC address para Wake-on-LAN
def load_targets():
    """Carga la lista de TVs desde fina_settings.json (máx 4, solo enabled).

    Si el archivo no existe o hay algún problema, vuelve a un valor por defecto
    equivalente al comportamiento anterior.
    """
    default_targets = [
        {"ip": "192.168.0.11", "mac": "38:c8:04:31:17:b0"},
        {"ip": "192.168.0.10", "mac": "34:51:80:f9:86:4a"},
    ]

    try:
        if not os.path.exists(SETTINGS_PATH):
            return default_targets

        with open(SETTINGS_PATH, "r", encoding="utf-8") as f:
            data = json.load(f)

        tvs = data.get("tvs", [])
        targets = []
        for tv in tvs[:4]:
            if not tv.get("enabled", True):
                continue
            ip = tv.get("ip")
            mac = tv.get("mac")
            if not ip or not mac:
                continue
            targets.append({"ip": ip, "mac": mac})

        return targets or default_targets
    except Exception:
        return default_targets

def wake_on_lan(mac_address, ip_hint=None):
    """Envía un paquete mágico WoL a la dirección MAC especificada"""
    try:
        # Limpiar MAC
        mac_clean = mac_address.replace(':', '').replace('-', '')
        if len(mac_clean) != 12:
            return False
            
        mac_bytes = bytes.fromhex(mac_clean)
        magic_packet = b'\xff' * 6 + mac_bytes * 16
        
        with socket.socket(socket.AF_INET, socket.SOCK_DGRAM) as sock:
            sock.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
            
            # 1. Enviar a broadcast general
            try:
                sock.sendto(magic_packet, ('<broadcast>', 9))
            except Exception:
                pass

            # 2. Enviar a broadcast de subred (más efectivo)
            if ip_hint:
                try:
                    # Asumiendo red clase C /24
                    parts = ip_hint.split('.')
                    subnet_broadcast = f"{parts[0]}.{parts[1]}.{parts[2]}.255"
                    sock.sendto(magic_packet, (subnet_broadcast, 9))
                except Exception:
                    pass
            
        return True
    except Exception as e:
        print(f'⚠ Error enviando WoL a {mac_address}: {e}')
        return False

def check_device_connection(ip):
    """Verifica si el dispositivo está conectado y responde"""
    try:
        result = subprocess.run(
            ['adb', 'devices'],
            capture_output=True,
            text=True,
            timeout=3
        )
        for line in result.stdout.split('\n'):
            if ip in line and 'device' in line and 'offline' not in line:
                return True
        return False
    except Exception:
        return False

def is_screen_on(ip):
    """Verifica si la pantalla ya está encendida via ADB"""
    try:
        # Check para diferentes versiones de Android TV
        result = subprocess.run(
            ['adb', '-s', f'{ip}:5555', 'shell', 'dumpsys', 'power'],
            capture_output=True,
            text=True,
            timeout=5
        )
        output = result.stdout
        # Patrones comunes que indican que está encendida
        if "mWakefulness=Awake" in output or "Display Power: state=ON" in output:
            return True
        return False
    except Exception:
        return False

def send_power_and_exit(ip):
    """Envía el comando de encendido (WAKEUP) y termina el script"""
    print(f'\n✓ CONECTADO A {ip}. Esperando estabilización (2s)...')
    time.sleep(2)
    
    # Intento 1: KEYCODE_WAKEUP (Despertar sin apagar si ya está encendida)
    print(f'Enviando comando WAKEUP...')
    try:
        subprocess.run(
            ['adb', '-s', f'{ip}:5555', 'shell', 'input', 'keyevent', 'KEYCODE_WAKEUP'],
            capture_output=True,
            timeout=15
        )
        
        # Por seguridad enviamos también KEYCODE_HOME por si WAKEUP no es soportado
        time.sleep(0.5)
        subprocess.run(
            ['adb', '-s', f'{ip}:5555', 'shell', 'input', 'keyevent', 'KEYCODE_HOME'],
            capture_output=True,
            timeout=5
        )

        print(f'✓ Comando enviado a {ip}. Terminando.')
        sys.exit(0)
    except Exception as e:
        print(f'✗ Error enviando power: {e}')
        sys.exit(1)

def send_power_and_exit(ip):
    """Envía WAKEUP. Si no funciona, escala a POWER."""
    print(f'\n✓ CONECTADO A {ip}. Esperando estabilización (2s)...')
    time.sleep(2)
    
    # 1. Verificar si ya está encendida
    if is_screen_on(ip):
         print(f"✓ La pantalla de {ip} ya está ENCENDIDA. Terminando.")
         sys.exit(0)

    # 2. Intento 1: WAKEUP
    print(f'Enviando comando WAKEUP...')
    try:
        subprocess.run(
            ['adb', '-s', f'{ip}:5555', 'shell', 'input', 'keyevent', 'KEYCODE_WAKEUP'],
            capture_output=True,
            timeout=15
        )
    except Exception:
        pass # Ignoramos errores aquí, verificaremos el estado real
        
    print("⏳ Verificando si encendió (4s)...")
    time.sleep(4)
    
    # 3. Verificar resultado
    if is_screen_on(ip):
        print(f"✓ La TV encendió correctamente con WAKEUP.")
        sys.exit(0)
        
    # 4. Plan B: POWER
    print("⚠ La pantalla sigue APAGADA. Intentando con POWER...")
    try:
        subprocess.run(
            ['adb', '-s', f'{ip}:5555', 'shell', 'input', 'keyevent', 'KEYCODE_POWER'],
            capture_output=True,
            timeout=15
        )
        print(f"✓ Comando POWER enviado. Terminando.")
        sys.exit(0)
    except Exception as e:
        print(f'✗ Error enviando POWER: {e}')
        sys.exit(1)

def connect_loop():
    """Ciclo principal: 1. Verificar ADB -> 2. WoL -> 3. Conectar"""
    print('=' * 60)
    print('TV ON - Modo Simple: Verificar -> WoL -> Conectar')
    print('=' * 60)
    
    targets = load_targets()
    cycle_count = 1
    max_cycles = 15 
    
    while cycle_count <= max_cycles:
        print(f'\n--- Intento #{cycle_count} ---')
        
        for target in targets:
            ip = target['ip']
            mac = target['mac']

            # 1. PRIMERO: Verificar si ya está conectada por ADB
            if check_device_connection(ip):
                print(f"✓ {ip} ya está conectada y respondiendo.")
                send_power_and_exit(ip) # Intenta encender y sale
            
            # 2. SI NO: Enviar WoL (Wake-on-LAN)
            print(f"○ {ip} desconectada. Enviando WoL...")
            wake_on_lan(mac, ip_hint=ip)
            
            # 3. Intentar conectar
            print(f"○ Intentando conectar ADB a {ip}...")
            try:
                subprocess.run(['adb', 'connect', ip], capture_output=True, timeout=3)
            except Exception:
                pass 
            
            # Verificar si conectó tras el WoL
            if check_device_connection(ip):
                 print(f"✓ Conexión exitosa tras WoL a {ip}.")
                 send_power_and_exit(ip)
        
        print("⏳ Esperando que la TV despierte...")
        time.sleep(4)
        cycle_count += 1

    print('\n✗ No se pudo conectar a la TV tras varios intentos.')
    sys.exit(1)

if __name__ == '__main__':
    try:
        connect_loop()
    except KeyboardInterrupt:
        print('\nCancelado por usuario.')
        sys.exit(1)
